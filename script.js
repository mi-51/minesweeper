let ゲーム盤の列の数 = 15;
let ゲーム盤の行の数 = 10;
let 爆弾;
let 開いたマス;
let 旗;
let 周囲の爆弾の数;
let ゲームの状態;

window.onload = function () {
  for (let y = 0; y < ゲーム盤の行の数; y += 1) {
    表のy行目を挿入する(y);
  }
  // リセットボタンをクリックした時にゲーム初期化処理を呼び出すようにする
  document.getElementById("リセットボタン").onclick = ゲーム初期化処理;
  // ウェブページを読み込んだ時（window.onload)にゲーム初期化処理を呼び出す
  ゲーム初期化処理();
};

function 表のy行目を挿入する(y) {
  let 表の要素オブジェクト = document.getElementById("ゲーム盤");
  let 行の要素オブジェクト, セルの要素オブジェクト;

  行の要素オブジェクト = document.createElement("tr");
  表の要素オブジェクト.appendChild(行の要素オブジェクト);
  for (let x = 0; x < ゲーム盤の列の数; x += 1) {
    セルの要素オブジェクト = document.createElement("td");
    セルの要素オブジェクト.onclick = function () {
      クリック処理(x, y);
    };
    // セルの上で右クリックした時に実行実行されるイベントハンドラの定義
    セルの要素オブジェクト.oncontextmenu = function () {
      旗の処理(x, y);
      // 最後に return false を記述することで、メニューが表示されなくなる
      return false;
    };
    セルの要素オブジェクト.id = `${x},${y}`;
    行の要素オブジェクト.appendChild(セルの要素オブジェクト);
  }
}

function クリック処理(x, y) {
  // "ゲーム中"以外の時は、return文で、この関数の処理を終了する
  if (ゲームの状態 !== "ゲーム中") {
    return;
  }

  開いたマス[x][y] = true;
  // 開いたマスが爆弾の場合は、ゲームの状態を"ゲームオーバー"にする
  if (爆弾[x][y]) {
    ゲームの状態 = "ゲームオーバー";
  }
  全ての周囲のマスを開く();
  ゲーム盤の表示の更新();
}

// 引数(x, y)のセルの上で、右クリックした時に実行される関数
function 旗の処理(x, y) {
  // (x, y)のマスの旗の「true」と「false」を反転する
  旗(x, y) = !旗(x, y);
  // console.log(旗[x][y]);

  // わかりにくければ以下のように記述しても良い
  // if (旗[x][y] = false) {
  //   旗[x][y] = true;
  // }
  // else {
  //   旗[x][y] = false;
  // }
  // ゲーム盤の表示を更新する（これを記述しないと画面の表示が更新されない！）
  ゲーム盤の表示の更新();
}

// ゲームを新しく開始する際の初期化処理を行う関数
function ゲーム初期化処理() {
  // ゲーム盤上の爆弾をすべてクリアする。開いたマスも同様にクリアする
  // 爆弾と開いたマスを空の配列で初期化する
  爆弾 = [];
  開いたマス = [];
  // 各列に対する繰り返し処理を行う
  for (let x = 0; x < ゲーム盤の列の数; x++) {
    // x列の要素に空の配列を代入する
    爆弾[x] = [];
    開いたマス[x] = [];
    // x列の各行に対する繰り返し処理を行う
    for (let y = 0; y < ゲーム盤の行の数; y++) {
      // 全ての(x, y) の組み合わせで下記のプログラムが実行される
      // 結果として「爆弾」と「開いたマス」のゲーム盤の全てのマスが false になる
      爆弾[x][y] = false;
      開いたマス[x][y] = false;
    }
  }

  let 爆弾の数;
  // どのラジオボタンがチェックされているかで配置する爆弾の数変える
  if (document.getElementById("易しい").checked) {
    // 易しい場合は全体のマスの10%だけ配置する
    爆弾の数 = ゲーム盤の行の数 * ゲーム盤の列の数 * 0.1;
  }
  else if (document.getElementById("普通").checked) {
    // 普通の場合は全体のマスの20%だけ配置する
    爆弾の数 = ゲーム盤の行の数 * ゲーム盤の列の数 * 0.2;
  }
  else {
    // 難しい場合は全体のマスの30%だけ配置する
    爆弾の数 = ゲーム盤の行の数 * ゲーム盤の列の数 * 0.3;
  }
  let 配置した爆弾の数 = 0;
  while (配置した爆弾の数 < 爆弾の数) {
    // 爆弾を1つランダムに配置する
    let x = サイコロを振る(ゲーム盤の列の数) - 1;
    let y = サイコロを振る(ゲーム盤の行の数) - 1;
    // 既に爆弾が（x, y）に配置済かどうかをチェックする
    if (爆弾[x][y] === false) {
      // 配置済でなければ、配置し、「配置した爆弾の数」数を1増やす
      爆弾[x][y] = true;
      配置した爆弾の数++;
      // (x, y)の周囲の爆弾の数を1増やす関数を呼び出す
      周囲の爆弾の数を増やす();
    }
  }

  // ゲームの状態を"ゲーム中"で初期化する
  ゲームの状態 = "ゲーム中";

  // ゲーム盤の表示を更新する
  ゲーム盤の表示の更新();
}

//  ゲーム盤の表示を更新更新する
function ゲーム盤の表示の更新() {
  // クリアまでの残りのマスの数を表す変数を「0」で初期化する
  let 残りのマスの数 = 0;
  // 繰り返しを入れ子にすることで、全てのマスに対して繰り返す
  for (let x = 0; x < ゲーム盤の列の数; x++) {
    for (let y = 0; y < ゲーム盤の行の数; y++) {
      // この中は、全ての(x, y)に対して1回ずつ実行される
      // (x, y)のマスの要素オブジェクトを取得する
      let 要素オブジェクト = document.getElementById(`${x},${y}`);
      let 塗りつぶしの色;
      let 表示する文字 = "";

      if (ゲームの状態 === "ゲームオーバー" && 爆弾(x, y) === true) {
        塗りつぶしの色 = 'red';
      }

      // (x, y) のマスが開いているかどうかをチェックする
      if (開いたマス[x][y] === false) {
        // マスが開いていなければ薄い灰色で塗りつぶす
        塗りつぶしの色 = "lightgray";
        // 閉じたマスで、爆弾がないマスの場合、「残りのマスの数」を1増やす
        if (爆弾[x][y] === false) {
          残りのマスの数++;
        }

        // if (旗[x][y] === false) {
        //   塗りつぶしの色 = "green";
        // }
      }
      else {
        // マスが開いている場合の処理
        // (x, y) のマスに爆弾マスがなければ、そのマスを白で塗りつぶす
        if (爆弾[x][y] === false) {
          表示する文字 = 周囲の爆弾の数(x, y);
          塗りつぶしの色 = "white";
          if (周囲の爆弾の数(x, y) === 0) {
            表示する文字 = "";
          }
        }
        // そうでなければ、そのマスを赤で塗りつぶす
        else {
          塗りつぶしの色 = "red";
        }
      } 要素オブジェクト.innerHTML = 表示する文字;
      要素オブジェクト.style.backgroundColor = 塗りつぶしの色;
    }
  }

  // クリアまでの残りのマスが「0」の場合、ゲームの状態を"クリア"にする
  if (残りのマスの数 === 0) {
    ゲームの状態 = "クリア";
  }

  // ゲーム盤の上にメッセージを表示する
  let メッセージ;
  // ゲームの状態をチェックする
  if (ゲームの状態 === "ゲーム中") {
    // ゲーム中の場合のメッセージに、残りのマスを設定する
    メッセージ = `あと ${残りのマスの数} マス`;
  }
  else if (ゲームの状態 === "ゲームオーバー") {
    // ゲームオーバーのメッセージを設定する
    メッセージ = "Game Over";
  }
  else {
    // クリア時のメッセージを設定する
    メッセージ = "クリア！！";
  }
  // メッセージを表示する
  document.getElementById("メッセージ").innerHTML = メッセージ;
}

function サイコロを振る(出目の最大値) {
  return Math.floor(Math.random() * 出目の最大値) + 1;
}

// 引数で指定した、(x, y) のマスの周囲8マスの爆弾の数を数え、
// 返り値として返す関数
// function 周囲の爆弾の数(x, y) {
//   // 周囲の爆弾の数を数を数えるための変数を「0」で初期化する
//   let 爆弾の数 = 0;
//   // 列方向の差分を表すカウンタ変数「dx」を使って -1 ～ 1 まで繰り返す
//   for (let dx = -1; dx <= 1; dx++) {
//     // 行方向の差分を表すカウンタ変数「dy」を使って -1 ～ 1 まで繰り返す
//     for (let dy = -1; dy <= 1; dy++) {
//       // 全ての(dx, dy) の組み合わせで下記のプログラムが実行される
//       // 結果として、(x, y)に差分を加えた(x + dx, x + dy)のマスに
//       // 対して下記のプログラムが実行される
//       // 爆弾が存在しない場合に「爆弾の数」を1増やす
//       if (ゲーム盤内のマスかどうか(x + dx, y + dy) && 爆弾[x + dx][y + dy]) {
//         爆弾の数++;
//       }
//     }
//   }
//   return 爆弾の数;
// }

// 引数(x, y)のマスが、ゲーム盤の中にある場合は「true」
// そうでなければ、「false」を返す関数
function ゲーム盤内のマスかどうか(x, y) {
  return 0 <= x && x < ゲーム盤の列の数 && 0 <= y && y < ゲーム盤の行の数;
}

// 引数(x, y)のマスの周囲の爆弾の数「0」の場合、周囲のマスを開き、開いた数を返す
function 周囲のマスを開く(x, y) {
  // 開いたマスの数を数える変数を「0」で初期化する
  let 開いたマスの数 = 0;
  if (周囲の爆弾の数(x, y) === 0) {
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        if (!(dx === 0 && dy === 0) && ゲーム盤内のマスかどうか(x + dx, y + dy)) {
          // 全ての(dx, dy) の組み合わせで下記のプログラムが実行される
          // 周囲8マスを開いたことにする
          if (開いたマス[x + dx][y + dy] === false) {
            // そのマスが開かれていない場合は、マスを開き、
            // 「開いたマスの数」に1を足す
            開いたマスの数++;
            開いたマス[x + dx][y + dy] = true;
          }
        }
      }
    }
  }
  // 開いたマスの数を返り値として返す
  return 開いたマスの数;
}

// 引数(x, y)のマスの周囲の「周囲の爆弾の数」を1つずつ増やす
function 周囲の爆弾の数を増やす(x, y) {
  for (let dx = -1; dx <= 1; dx++) {
    for (let dy = -1; dy <= 1; dy++) {
      if (ゲーム盤内のマスかどうか(x + dx, y + dy)) {
        ;
      }
    }
  }
}

// 開いているマスで、周囲の爆弾の数が「0」の周囲のマスを全て開く
function 全ての周囲のマスを開く() {
  while (true) {
    // 新しく開いたマスの数を数える変数を「0」で初期化する
    let 新しく開いたマスの数 = 0;
    for (let x = 0; x < ゲーム盤の列の数; x++) {
      for (let y = 0; y < ゲーム盤の行の数; y++) {
        if (開いたマス[x][y] === true && 周囲の爆弾の数[x][y] === 0) {
          // 「周囲のマスを開く」を呼び出して、周囲のマスを開く
          // この関数は、開いたマスの数をを返すので、
          // その値値を「新しく開いたマスの数」に加算する
          新しく開いたマスの数 += 周囲のマスを開く(x, y);
        }
      }
    }
    if (新しく開いたマスの数 === 0) {
      break;
    }
  }
}